/* parser auto-generated by pidl */

#include "includes.h"
#include "bin/default/librpc/gen_ndr/ndr_bkupblobs.h"

#include "librpc/gen_ndr/ndr_misc.h"
#include "librpc/gen_ndr/ndr_security.h"
#include "librpc/gen_ndr/ndr_fscc.h"
static enum ndr_err_code ndr_push_bkup_StreamId(struct ndr_push *ndr, int ndr_flags, enum bkup_StreamId r)
{
	NDR_CHECK(ndr_push_enum_uint32(ndr, NDR_SCALARS, r));
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_bkup_StreamId(struct ndr_pull *ndr, int ndr_flags, enum bkup_StreamId *r)
{
	uint32_t v;
	NDR_CHECK(ndr_pull_enum_uint32(ndr, NDR_SCALARS, &v));
	*r = v;
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_bkup_StreamId(struct ndr_print *ndr, const char *name, enum bkup_StreamId r)
{
	const char *val = NULL;

	switch (r) {
		case STREAM_ID_DATA: val = "STREAM_ID_DATA"; break;
		case STREAM_ID_EX_DATA: val = "STREAM_ID_EX_DATA"; break;
		case STREAM_ID_SECURITY_DATA: val = "STREAM_ID_SECURITY_DATA"; break;
		case STREAM_ID_ALTERNATE_DATA: val = "STREAM_ID_ALTERNATE_DATA"; break;
		case STREAM_ID_LINK: val = "STREAM_ID_LINK"; break;
		case STREAM_ID_OBJECTID: val = "STREAM_ID_OBJECTID"; break;
		case STREAM_ID_REPARSE_DATA: val = "STREAM_ID_REPARSE_DATA"; break;
		case STREAM_ID_SPARSE_BLOCK: val = "STREAM_ID_SPARSE_BLOCK"; break;
		case STREAM_ID_TXFS_DATA: val = "STREAM_ID_TXFS_DATA"; break;
	}
	ndr_print_enum(ndr, name, "ENUM", val, r);
}

static enum ndr_err_code ndr_push_bkup_StreamAttribute(struct ndr_push *ndr, int ndr_flags, enum bkup_StreamAttribute r)
{
	NDR_CHECK(ndr_push_enum_uint32(ndr, NDR_SCALARS, r));
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_bkup_StreamAttribute(struct ndr_pull *ndr, int ndr_flags, enum bkup_StreamAttribute *r)
{
	uint32_t v;
	NDR_CHECK(ndr_pull_enum_uint32(ndr, NDR_SCALARS, &v));
	*r = v;
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_bkup_StreamAttribute(struct ndr_print *ndr, const char *name, enum bkup_StreamAttribute r)
{
	const char *val = NULL;

	switch (r) {
		case STREAM_ATTRIBUTE_NORMAL: val = "STREAM_ATTRIBUTE_NORMAL"; break;
		case STREAM_ATTRIBUTE_SECURITY: val = "STREAM_ATTRIBUTE_SECURITY"; break;
		case STREAM_ATTRIBUTE_SPARSE: val = "STREAM_ATTRIBUTE_SPARSE"; break;
	}
	ndr_print_enum(ndr, name, "ENUM", val, r);
}

static enum ndr_err_code ndr_push_bkup_StreamData(struct ndr_push *ndr, int ndr_flags, const union bkup_StreamData *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		NDR_CHECK(ndr_push_union_align(ndr, 5));
		switch (level) {
			default: {
				NDR_CHECK(ndr_push_DATA_BLOB(ndr, NDR_SCALARS, r->blob));
			break; }

			case STREAM_ID_SECURITY_DATA: {
				{
					uint32_t _flags_save_security_descriptor = ndr->flags;
					ndr_set_flags(&ndr->flags, LIBNDR_FLAG_ALIGN2);
					NDR_CHECK(ndr_push_security_descriptor(ndr, NDR_SCALARS, &r->sd));
					ndr->flags = _flags_save_security_descriptor;
				}
			break; }

			case STREAM_ID_OBJECTID: {
				NDR_CHECK(ndr_push_fscc_FileObjectIdBuffer_2(ndr, NDR_SCALARS, &r->object));
			break; }

		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			default:
			break;

			case STREAM_ID_SECURITY_DATA:
				{
					uint32_t _flags_save_security_descriptor = ndr->flags;
					ndr_set_flags(&ndr->flags, LIBNDR_FLAG_ALIGN2);
					NDR_CHECK(ndr_push_security_descriptor(ndr, NDR_BUFFERS, &r->sd));
					ndr->flags = _flags_save_security_descriptor;
				}
			break;

			case STREAM_ID_OBJECTID:
			break;

		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_bkup_StreamData(struct ndr_pull *ndr, int ndr_flags, union bkup_StreamData *r)
{
	uint32_t level;
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		level = ndr_pull_get_switch_value(ndr, r);
		NDR_CHECK(ndr_pull_union_align(ndr, 5));
		switch (level) {
			default: {
				NDR_CHECK(ndr_pull_DATA_BLOB(ndr, NDR_SCALARS, &r->blob));
			break; }

			case STREAM_ID_SECURITY_DATA: {
				{
					uint32_t _flags_save_security_descriptor = ndr->flags;
					ndr_set_flags(&ndr->flags, LIBNDR_FLAG_ALIGN2);
					NDR_CHECK(ndr_pull_security_descriptor(ndr, NDR_SCALARS, &r->sd));
					ndr->flags = _flags_save_security_descriptor;
				}
			break; }

			case STREAM_ID_OBJECTID: {
				NDR_CHECK(ndr_pull_fscc_FileObjectIdBuffer_2(ndr, NDR_SCALARS, &r->object));
			break; }

		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		/* The token is not needed after this. */
		level = ndr_pull_steal_switch_value(ndr, r);
		switch (level) {
			default:
			break;

			case STREAM_ID_SECURITY_DATA:
				{
					uint32_t _flags_save_security_descriptor = ndr->flags;
					ndr_set_flags(&ndr->flags, LIBNDR_FLAG_ALIGN2);
					NDR_CHECK(ndr_pull_security_descriptor(ndr, NDR_BUFFERS, &r->sd));
					ndr->flags = _flags_save_security_descriptor;
				}
			break;

			case STREAM_ID_OBJECTID:
			break;

		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_bkup_StreamData(struct ndr_print *ndr, const char *name, const union bkup_StreamData *r)
{
	uint32_t level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "bkup_StreamData");
	switch (level) {
		default:
			ndr_print_DATA_BLOB(ndr, "blob", r->blob);
		break;

		case STREAM_ID_SECURITY_DATA:
			ndr_print_security_descriptor(ndr, "sd", &r->sd);
		break;

		case STREAM_ID_OBJECTID:
			ndr_print_fscc_FileObjectIdBuffer_2(ndr, "object", &r->object);
		break;

	}
}

_PUBLIC_ enum ndr_err_code ndr_push_bkup_Win32StreamId(struct ndr_push *ndr, int ndr_flags, const struct bkup_Win32StreamId *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_bkup_StreamId(ndr, NDR_SCALARS, r->id));
		NDR_CHECK(ndr_push_bkup_StreamAttribute(ndr, NDR_SCALARS, r->attribute));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->size));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->stream_name_size));
		{
			uint32_t _flags_save_uint16 = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM);
			NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, r->stream_name, r->stream_name_size, sizeof(uint16_t), CH_UTF16));
			ndr->flags = _flags_save_uint16;
		}
		{
			uint32_t _flags_save_bkup_StreamData = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			{
				struct ndr_push *_ndr_data;
				NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_data, 0, r->size));
				NDR_CHECK(ndr_push_set_switch_value(_ndr_data, &r->data, r->id));
				NDR_CHECK(ndr_push_bkup_StreamData(_ndr_data, NDR_SCALARS|NDR_BUFFERS, &r->data));
				NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_data, 0, r->size));
			}
			ndr->flags = _flags_save_bkup_StreamData;
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		{
			uint32_t _flags_save_bkup_StreamData = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			ndr->flags = _flags_save_bkup_StreamData;
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_bkup_Win32StreamId(struct ndr_pull *ndr, int ndr_flags, struct bkup_Win32StreamId *r)
{
	uint32_t size_stream_name_0 = 0;
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_bkup_StreamId(ndr, NDR_SCALARS, &r->id));
		NDR_CHECK(ndr_pull_bkup_StreamAttribute(ndr, NDR_SCALARS, &r->attribute));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->size));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->stream_name_size));
		{
			uint32_t _flags_save_uint16 = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM);
			size_stream_name_0 = r->stream_name_size;
			NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->stream_name, size_stream_name_0, sizeof(uint16_t), CH_UTF16));
			ndr->flags = _flags_save_uint16;
		}
		{
			uint32_t _flags_save_bkup_StreamData = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			{
				struct ndr_pull *_ndr_data;
				NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_data, 0, r->size));
				NDR_CHECK(ndr_pull_set_switch_value(_ndr_data, &r->data, r->id));
				NDR_CHECK(ndr_pull_bkup_StreamData(_ndr_data, NDR_SCALARS|NDR_BUFFERS, &r->data));
				NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_data, 0, r->size));
			}
			ndr->flags = _flags_save_bkup_StreamData;
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		{
			uint32_t _flags_save_bkup_StreamData = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			ndr->flags = _flags_save_bkup_StreamData;
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_bkup_Win32StreamId(struct ndr_print *ndr, const char *name, const struct bkup_Win32StreamId *r)
{
	ndr_print_struct(ndr, name, "bkup_Win32StreamId");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_bkup_StreamId(ndr, "id", r->id);
	ndr_print_bkup_StreamAttribute(ndr, "attribute", r->attribute);
	ndr_print_hyper(ndr, "size", r->size);
	ndr_print_uint32(ndr, "stream_name_size", r->stream_name_size);
	ndr_print_string(ndr, "stream_name", r->stream_name);
	ndr_print_set_switch_value(ndr, &r->data, r->id);
	ndr_print_bkup_StreamData(ndr, "data", &r->data);
	ndr->depth--;
}

_PUBLIC_ void ndr_print_bkup_NTBackupFile(struct ndr_print *ndr, const char *name, const struct bkup_NTBackupFile *r)
{
	uint32_t cntr_streams_0;
	ndr_print_struct(ndr, name, "bkup_NTBackupFile");
	if (r == NULL) { ndr_print_null(ndr); return; }
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		ndr->depth++;
		ndr_print_uint32(ndr, "num_stream", r->num_stream);
		ndr->print(ndr, "%s: ARRAY(%d)", "streams", (int)r->num_stream);
		ndr->depth++;
		for (cntr_streams_0 = 0; cntr_streams_0 < (r->num_stream); cntr_streams_0++) {
			ndr_print_bkup_Win32StreamId(ndr, "streams", &r->streams[cntr_streams_0]);
		}
		ndr->depth--;
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

