/* parser auto-generated by pidl */

#include "includes.h"
#include "bin/default/source3/librpc/gen_ndr/ndr_leases_db.h"

#include "librpc/gen_ndr/ndr_misc.h"
#include "librpc/gen_ndr/ndr_smb2_lease_struct.h"
#include "librpc/gen_ndr/ndr_file_id.h"
_PUBLIC_ enum ndr_err_code ndr_push_leases_db_key(struct ndr_push *ndr, int ndr_flags, const struct leases_db_key *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->client_guid));
		NDR_CHECK(ndr_push_smb2_lease_key(ndr, NDR_SCALARS, &r->lease_key));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_leases_db_key(struct ndr_pull *ndr, int ndr_flags, struct leases_db_key *r)
{
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->client_guid));
		NDR_CHECK(ndr_pull_smb2_lease_key(ndr, NDR_SCALARS, &r->lease_key));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_leases_db_key(struct ndr_print *ndr, const char *name, const struct leases_db_key *r)
{
	ndr_print_struct(ndr, name, "leases_db_key");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_GUID(ndr, "client_guid", &r->client_guid);
	ndr_print_smb2_lease_key(ndr, "lease_key", &r->lease_key);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_leases_db_file(struct ndr_push *ndr, int ndr_flags, const struct leases_db_file *r)
{
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 5));
		NDR_CHECK(ndr_push_file_id(ndr, NDR_SCALARS, &r->id));
		NDR_CHECK(ndr_push_unique_ptr(ndr, r->servicepath));
		NDR_CHECK(ndr_push_unique_ptr(ndr, r->base_name));
		NDR_CHECK(ndr_push_unique_ptr(ndr, r->stream_name));
		NDR_CHECK(ndr_push_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->servicepath) {
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, ndr_charset_length(r->servicepath, CH_UTF8)));
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, 0));
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, ndr_charset_length(r->servicepath, CH_UTF8)));
			NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, r->servicepath, ndr_charset_length(r->servicepath, CH_UTF8), sizeof(uint8_t), CH_UTF8));
		}
		if (r->base_name) {
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, ndr_charset_length(r->base_name, CH_UTF8)));
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, 0));
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, ndr_charset_length(r->base_name, CH_UTF8)));
			NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, r->base_name, ndr_charset_length(r->base_name, CH_UTF8), sizeof(uint8_t), CH_UTF8));
		}
		if (r->stream_name) {
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, ndr_charset_length(r->stream_name, CH_UTF8)));
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, 0));
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, ndr_charset_length(r->stream_name, CH_UTF8)));
			NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, r->stream_name, ndr_charset_length(r->stream_name, CH_UTF8), sizeof(uint8_t), CH_UTF8));
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_leases_db_file(struct ndr_pull *ndr, int ndr_flags, struct leases_db_file *r)
{
	uint32_t _ptr_servicepath;
	uint32_t size_servicepath_1 = 0;
	uint32_t length_servicepath_1 = 0;
	TALLOC_CTX *_mem_save_servicepath_0 = NULL;
	uint32_t _ptr_base_name;
	uint32_t size_base_name_1 = 0;
	uint32_t length_base_name_1 = 0;
	TALLOC_CTX *_mem_save_base_name_0 = NULL;
	uint32_t _ptr_stream_name;
	uint32_t size_stream_name_1 = 0;
	uint32_t length_stream_name_1 = 0;
	TALLOC_CTX *_mem_save_stream_name_0 = NULL;
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 5));
		NDR_CHECK(ndr_pull_file_id(ndr, NDR_SCALARS, &r->id));
		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_servicepath));
		if (_ptr_servicepath) {
			NDR_PULL_ALLOC(ndr, r->servicepath);
		} else {
			r->servicepath = NULL;
		}
		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_base_name));
		if (_ptr_base_name) {
			NDR_PULL_ALLOC(ndr, r->base_name);
		} else {
			r->base_name = NULL;
		}
		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_stream_name));
		if (_ptr_stream_name) {
			NDR_PULL_ALLOC(ndr, r->stream_name);
		} else {
			r->stream_name = NULL;
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->servicepath) {
			_mem_save_servicepath_0 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, r->servicepath, 0);
			NDR_CHECK(ndr_pull_array_size(ndr, &r->servicepath));
			NDR_CHECK(ndr_pull_array_length(ndr, &r->servicepath));
			size_servicepath_1 = ndr_get_array_size(ndr, &r->servicepath);
			length_servicepath_1 = ndr_get_array_length(ndr, &r->servicepath);
			if (length_servicepath_1 > size_servicepath_1) {
				return ndr_pull_error(ndr, NDR_ERR_ARRAY_SIZE, "Bad array size %u should exceed array length %u", size_servicepath_1, length_servicepath_1);
			}
			NDR_CHECK(ndr_check_string_terminator(ndr, length_servicepath_1, sizeof(uint8_t)));
			NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->servicepath, length_servicepath_1, sizeof(uint8_t), CH_UTF8));
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_servicepath_0, 0);
		}
		if (r->base_name) {
			_mem_save_base_name_0 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, r->base_name, 0);
			NDR_CHECK(ndr_pull_array_size(ndr, &r->base_name));
			NDR_CHECK(ndr_pull_array_length(ndr, &r->base_name));
			size_base_name_1 = ndr_get_array_size(ndr, &r->base_name);
			length_base_name_1 = ndr_get_array_length(ndr, &r->base_name);
			if (length_base_name_1 > size_base_name_1) {
				return ndr_pull_error(ndr, NDR_ERR_ARRAY_SIZE, "Bad array size %u should exceed array length %u", size_base_name_1, length_base_name_1);
			}
			NDR_CHECK(ndr_check_string_terminator(ndr, length_base_name_1, sizeof(uint8_t)));
			NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->base_name, length_base_name_1, sizeof(uint8_t), CH_UTF8));
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_base_name_0, 0);
		}
		if (r->stream_name) {
			_mem_save_stream_name_0 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, r->stream_name, 0);
			NDR_CHECK(ndr_pull_array_size(ndr, &r->stream_name));
			NDR_CHECK(ndr_pull_array_length(ndr, &r->stream_name));
			size_stream_name_1 = ndr_get_array_size(ndr, &r->stream_name);
			length_stream_name_1 = ndr_get_array_length(ndr, &r->stream_name);
			if (length_stream_name_1 > size_stream_name_1) {
				return ndr_pull_error(ndr, NDR_ERR_ARRAY_SIZE, "Bad array size %u should exceed array length %u", size_stream_name_1, length_stream_name_1);
			}
			NDR_CHECK(ndr_check_string_terminator(ndr, length_stream_name_1, sizeof(uint8_t)));
			NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->stream_name, length_stream_name_1, sizeof(uint8_t), CH_UTF8));
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_stream_name_0, 0);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_leases_db_file(struct ndr_print *ndr, const char *name, const struct leases_db_file *r)
{
	ndr_print_struct(ndr, name, "leases_db_file");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_file_id(ndr, "id", &r->id);
	ndr_print_ptr(ndr, "servicepath", r->servicepath);
	ndr->depth++;
	if (r->servicepath) {
		ndr_print_string(ndr, "servicepath", r->servicepath);
	}
	ndr->depth--;
	ndr_print_ptr(ndr, "base_name", r->base_name);
	ndr->depth++;
	if (r->base_name) {
		ndr_print_string(ndr, "base_name", r->base_name);
	}
	ndr->depth--;
	ndr_print_ptr(ndr, "stream_name", r->stream_name);
	ndr->depth++;
	if (r->stream_name) {
		ndr_print_string(ndr, "stream_name", r->stream_name);
	}
	ndr->depth--;
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_leases_db_value(struct ndr_push *ndr, int ndr_flags, const struct leases_db_value *r)
{
	uint32_t cntr_files_0;
	NDR_PUSH_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->num_files));
		NDR_CHECK(ndr_push_align(ndr, 5));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->num_files));
		for (cntr_files_0 = 0; cntr_files_0 < (r->num_files); cntr_files_0++) {
			NDR_CHECK(ndr_push_leases_db_file(ndr, NDR_SCALARS, &r->files[cntr_files_0]));
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		for (cntr_files_0 = 0; cntr_files_0 < (r->num_files); cntr_files_0++) {
			NDR_CHECK(ndr_push_leases_db_file(ndr, NDR_BUFFERS, &r->files[cntr_files_0]));
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_leases_db_value(struct ndr_pull *ndr, int ndr_flags, struct leases_db_value *r)
{
	uint32_t size_files_0 = 0;
	uint32_t cntr_files_0;
	TALLOC_CTX *_mem_save_files_0 = NULL;
	NDR_PULL_CHECK_FLAGS(ndr, ndr_flags);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_array_size(ndr, &r->files));
		NDR_CHECK(ndr_pull_align(ndr, 5));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->num_files));
		size_files_0 = ndr_get_array_size(ndr, &r->files);
		NDR_PULL_ALLOC_N(ndr, r->files, size_files_0);
		_mem_save_files_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->files, 0);
		for (cntr_files_0 = 0; cntr_files_0 < (size_files_0); cntr_files_0++) {
			NDR_CHECK(ndr_pull_leases_db_file(ndr, NDR_SCALARS, &r->files[cntr_files_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_files_0, 0);
		if (r->files) {
			NDR_CHECK(ndr_check_array_size(ndr, (void*)&r->files, r->num_files));
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		size_files_0 = ndr_get_array_size(ndr, &r->files);
		_mem_save_files_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->files, 0);
		for (cntr_files_0 = 0; cntr_files_0 < (size_files_0); cntr_files_0++) {
			NDR_CHECK(ndr_pull_leases_db_file(ndr, NDR_BUFFERS, &r->files[cntr_files_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_files_0, 0);
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_leases_db_value(struct ndr_print *ndr, const char *name, const struct leases_db_value *r)
{
	uint32_t cntr_files_0;
	ndr_print_struct(ndr, name, "leases_db_value");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "num_files", r->num_files);
	ndr->print(ndr, "%s: ARRAY(%d)", "files", (int)r->num_files);
	ndr->depth++;
	for (cntr_files_0 = 0; cntr_files_0 < (r->num_files); cntr_files_0++) {
		ndr_print_leases_db_file(ndr, "files", &r->files[cntr_files_0]);
	}
	ndr->depth--;
	ndr->depth--;
}

