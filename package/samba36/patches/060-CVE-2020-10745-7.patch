Backport of:

From 40e3fc9314eca317cd373fde624f57a9fc4f8237 Mon Sep 17 00:00:00 2001
From: Douglas Bagnall <douglas.bagnall@catalyst.net.nz>
Date: Fri, 15 May 2020 10:52:45 +1200
Subject: [PATCH 7/7] CVE-2020-10745: ndr/dns-utils: prepare for NBT
 compatibility

NBT has a funny thing where it sometimes needs to send a trailing dot as
part of the last component, because the string representation is a user
name. In DNS, "example.com", and "example.com." are the same, both
having three components ("example", "com", ""); in NBT, we want to treat
them differently, with the second form having the three components
("example", "com.", "").

This retains the logic of e6e2ec0001fe3c010445e26cc0efddbc1f73416b.

Also DNS compression cannot be turned off for NBT.

BUG: https://bugzilla.samba.org/show_bug.cgi?id=14378

Signed-off-by: Douglas Bagnall <douglas.bagnall@catalyst.net.nz>
diff --git a/libcli/nbt/nbtname.c b/libcli/nbt/nbtname.c
index fec8e8e..f403fad 100644
--- a/libcli/nbt/nbtname.c
+++ b/libcli/nbt/nbtname.c
@@ -28,6 +28,7 @@
 #include "librpc/gen_ndr/ndr_misc.h"
 #include "system/locale.h"
 #include "lib/util/util_net.h"
+#include "librpc/ndr/libndr.h"
 
 /* don't allow an unlimited number of name components */
 #define MAX_COMPONENTS 10
@@ -139,11 +140,41 @@ _PUBLIC_ enum ndr_err_code ndr_pull_nbt_string(struct ndr_pull *ndr, int ndr_fla
 	return NDR_ERR_SUCCESS;
 }
 
+// Duplicating this and adding here
+// in order to cover CVE-2020-10745
+// TODO: Remove it from here and include for
+// librpc instead in the future.
+
 /**
-  push a nbt string to the wire
+  push a dns/nbt string list to the wire
 */
-_PUBLIC_ enum ndr_err_code ndr_push_nbt_string(struct ndr_push *ndr, int ndr_flags, const char *s)
+enum ndr_err_code _ndr_push_dns_string_list(struct ndr_push *ndr,
+					   struct ndr_token_list **string_list,
+					   int ndr_flags,
+					   const char *s,
+					   bool is_nbt)
 {
+	const char *start = s;
+	size_t max_length;
+	if (is_nbt) {
+		/*
+		 * Max length is longer in NBT/Wins, because Windows counts
+		 * the semi-decompressed size of the netbios name (16 bytes)
+		 * rather than the wire size of 32, which is what you'd expect
+		 * if it followed RFC1002 (it uses the short form in
+		 * [MS-WINSRA]). In other words the maximum size of the
+		 * "scope" is 237, not 221.
+		 *
+		 * We make the size limit slightly larger than 255 + 16,
+		 * because the 237 scope limit is already enforced in the
+		 * winsserver code with a specific return value; bailing out
+		 * here would muck with that.
+		 */
+		max_length = 274;
+	} else {
+		max_length = 255;
+	}
+
 	if (!(ndr_flags & NDR_SCALARS)) {
 		return NDR_ERR_SUCCESS;
 	}
@@ -154,16 +185,21 @@ _PUBLIC_ enum ndr_err_code ndr_push_nbt_string(struct ndr_push *ndr, int ndr_fla
 		size_t complen;
 		uint32_t offset;
 
-		/* see if we have pushed the remaing string allready,
+		/* see if we have pushed the remaining string already,
 		 * if so we use a label pointer to this string
 		 */
-		ndr_err = ndr_token_retrieve_cmp_fn(&ndr->nbt_string_list, s, &offset, (comparison_fn_t)strcmp, false);
+		ndr_err = ndr_token_retrieve_cmp_fn(string_list, s,
+						    &offset,
+						    (comparison_fn_t)strcmp,
+						    false);
 		if (NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
 			uint8_t b[2];
 
 			if (offset > 0x3FFF) {
 				return ndr_push_error(ndr, NDR_ERR_STRING,
-						      "offset for nbt string label pointer %u[%08X] > 0x00003FFF",
+						      "offset for dns string " \
+						      "label pointer " \
+						      "%u[%08X] > 0x00003FFF",
 						      offset, offset);
 			}
 
@@ -175,11 +211,27 @@ _PUBLIC_ enum ndr_err_code ndr_push_nbt_string(struct ndr_push *ndr, int ndr_fla
 
 		complen = strcspn(s, ".");
 
-		/* we need to make sure the length fits into 6 bytes */
+		/* the length must fit into 6 bits (i.e. <= 63) */
 		if (complen > 0x3F) {
 			return ndr_push_error(ndr, NDR_ERR_STRING,
-					      "component length %u[%08X] > 0x0000003F",
-					      (unsigned)complen, (unsigned)complen);
+					      "component length %u[%08X] > " \
+					      "0x0000003F",
+					      (unsigned)complen,
+					      (unsigned)complen);
+		}
+
+		if (complen == 0 && s[complen] == '.') {
+			return ndr_push_error(ndr, NDR_ERR_STRING,
+					      "component length is 0 "
+					      "(consecutive dots)");
+		}
+
+		if (is_nbt && s[complen] == '.' && s[complen + 1] == '\0') {
+			/* nbt names are sometimes usernames, and we need to
+			 * keep a trailing dot to ensure it is byte-identical,
+			 * (not just semantically identical given DNS
+			 * semantics). */
+			complen++;
 		}
 
 		compname = talloc_asprintf(ndr, "%c%*.*s",
@@ -188,17 +240,26 @@ _PUBLIC_ enum ndr_err_code ndr_push_nbt_string(struct ndr_push *ndr, int ndr_fla
 						(unsigned char)complen, s);
 		NDR_ERR_HAVE_NO_MEMORY(compname);
 
-		/* remember the current componemt + the rest of the string
+		/* remember the current component + the rest of the string
 		 * so it can be reused later
 		 */
-		NDR_CHECK(ndr_token_store(ndr, &ndr->nbt_string_list, s, ndr->offset));
+		NDR_CHECK(ndr_token_store(ndr, string_list, s,
+					  ndr->offset));
 
 		/* push just this component into the blob */
-		NDR_CHECK(ndr_push_bytes(ndr, (const uint8_t *)compname, complen+1));
+		NDR_CHECK(ndr_push_bytes(ndr, (const uint8_t *)compname,
+					 complen+1));
 		talloc_free(compname);
 
 		s += complen;
-		if (*s == '.') s++;
+		if (*s == '.') {
+			s++;
+		}
+		if (s - start > max_length) {
+			return ndr_push_error(ndr, NDR_ERR_STRING,
+					      "name > %zu character long",
+					      max_length);
+		}
 	}
 
 	/* if we reach the end of the string and have pushed the last component
@@ -206,6 +267,17 @@ _PUBLIC_ enum ndr_err_code ndr_push_nbt_string(struct ndr_push *ndr, int ndr_fla
 	 */
 	return ndr_push_bytes(ndr, (const uint8_t *)"", 1);
 }
+/**
+  push a nbt string to the wire
+*/
+_PUBLIC_ enum ndr_err_code ndr_push_nbt_string(struct ndr_push *ndr, int ndr_flags, const char *s)
+{
+	return _ndr_push_dns_string_list(ndr,
+					&ndr->dns_string_list,
+					ndr_flags,
+					s,
+					true);
+}
 
 
 /*
diff --git a/librpc/ndr/ndr_dns.c b/librpc/ndr/ndr_dns.c
index 887da81..63d64e5 100644
--- a/librpc/ndr/ndr_dns.c
+++ b/librpc/ndr/ndr_dns.c
@@ -162,7 +162,8 @@ _PUBLIC_ enum ndr_err_code ndr_push_dns_string(struct ndr_push *ndr,
 	return ndr_push_dns_string_list(ndr,
 					&ndr->dns_string_list,
 					ndr_flags,
-					s);
+					s,
+					false);
 }
 
 _PUBLIC_ enum ndr_err_code ndr_push_dns_res_rec(struct ndr_push *ndr,
diff --git a/librpc/ndr/ndr_dns_utils.c b/librpc/ndr/ndr_dns_utils.c
index 0fe9a14..66ba65d 100644
--- a/librpc/ndr/ndr_dns_utils.c
+++ b/librpc/ndr/ndr_dns_utils.c
@@ -9,9 +9,29 @@
 enum ndr_err_code ndr_push_dns_string_list(struct ndr_push *ndr,
 					   struct ndr_token_list **string_list,
 					   int ndr_flags,
-					   const char *s)
+					   const char *s,
+					   bool is_nbt)
 {
 	const char *start = s;
+	size_t max_length;
+	if (is_nbt) {
+		/*
+		 * Max length is longer in NBT/Wins, because Windows counts
+		 * the semi-decompressed size of the netbios name (16 bytes)
+		 * rather than the wire size of 32, which is what you'd expect
+		 * if it followed RFC1002 (it uses the short form in
+		 * [MS-WINSRA]). In other words the maximum size of the
+		 * "scope" is 237, not 221.
+		 *
+		 * We make the size limit slightly larger than 255 + 16,
+		 * because the 237 scope limit is already enforced in the
+		 * winsserver code with a specific return value; bailing out
+		 * here would muck with that.
+		 */
+		max_length = 274;
+	} else {
+		max_length = 255;
+	}
 
 	if (!(ndr_flags & NDR_SCALARS)) {
 		return NDR_ERR_SUCCESS;
@@ -64,6 +84,14 @@ enum ndr_err_code ndr_push_dns_string_list(struct ndr_push *ndr,
 					      "(consecutive dots)");
 		}
 
+		if (is_nbt && s[complen] == '.' && s[complen + 1] == '\0') {
+			/* nbt names are sometimes usernames, and we need to
+			 * keep a trailing dot to ensure it is byte-identical,
+			 * (not just semantically identical given DNS
+			 * semantics). */
+			complen++;
+		}
+
 		compname = talloc_asprintf(ndr, "%c%*.*s",
 						(unsigned char)complen,
 						(unsigned char)complen,
@@ -85,9 +113,10 @@ enum ndr_err_code ndr_push_dns_string_list(struct ndr_push *ndr,
 		if (*s == '.') {
 			s++;
 		}
-		if (s - start > 255) {
+		if (s - start > max_length) {
 			return ndr_push_error(ndr, NDR_ERR_STRING,
-					      "name > 255 character long");
+					      "name > %zu character long",
+					      max_length);
 		}
 	}
 
diff --git a/librpc/ndr/ndr_dns_utils.h b/librpc/ndr/ndr_dns_utils.h
index 9e80db5..de41b61 100644
--- a/librpc/ndr/ndr_dns_utils.h
+++ b/librpc/ndr/ndr_dns_utils.h
@@ -2,4 +2,5 @@
 enum ndr_err_code ndr_push_dns_string_list(struct ndr_push *ndr,
 					   struct ndr_token_list **string_list,
 					   int ndr_flags,
-					   const char *s);
+					   const char *s,
+					   bool is_nbt);
diff --git a/librpc/wscript_build b/librpc/wscript_build
index e275e9e..7d87df7 100644
--- a/librpc/wscript_build
+++ b/librpc/wscript_build
@@ -324,7 +324,7 @@ bld.SAMBA_SUBSYSTEM('NDR_SCHANNEL',
 
 bld.SAMBA_SUBSYSTEM('NDR_NBT',
 	source='gen_ndr/ndr_nbt.c',
-	public_deps='ndr NDR_NBT_BUF NDR_SECURITY ndr-standard LIBCLI_NDR_NETLOGON',
+	public_deps='ndr NDR_NBT_BUF NDR_SECURITY NDR_DNS ndr-standard LIBCLI_NDR_NETLOGON',
 	public_headers='gen_ndr/nbt.h',
         header_path='gen_ndr'
 	)
